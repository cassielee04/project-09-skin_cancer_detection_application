"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const watch = require("node-watch");
const debounce = require("debounce");
const minimatch = require("minimatch");
const utils_1 = require("../utils/utils");
const Package_1 = require("../Package/Package");
class ObservablePackage extends Package_1.default {
    constructor(path, npmy) {
        super(path, npmy);
        this.path = path;
        this.npmy = npmy;
        this.processing = false;
        this.taskRetries = 0;
        this.tasks = [];
        this.gitignore = [];
        this.rsyncGhostPath = path_1.join(utils_1.tmpdir(), this.name.replace(/[^a-z_0-9-]/gi, '_'));
        this.ghostPath = path_1.join(this.rsyncGhostPath, path_1.basename(this.path));
    }
    expire(rsync) {
        this.tasks = [];
        rsync && this.addTask(() => this.rsyncGhost(true));
        this.simulatePublish();
        this.addTask(() => this.log(`Published`));
    }
    addTask(exec) {
        this.tasks.push(exec);
        this.runNextTask();
    }
    simulatePublish() {
        this.addTask(() => this.time('simulatePublish'));
        this.addTask(() => this.execHook('prepare'));
        this.addTask(() => this.execHook('prepublishOnly'));
        this.addTask(() => this.execHook('prepublish'));
        this.addTask(() => this.execHook('publish'));
        this.addTask(() => this.cleanGhostAfterPublish());
        this.addTask(() => this.timeEnd('simulatePublish'));
    }
    getPathToPublished() {
        return this.ghostPath;
    }
    runInstall(createBinScripts) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("runInstall").call(this, createBinScripts);
            yield this.rsyncGhost(false);
            yield this.readGitignore();
            this.expire(false);
            this.startWatcher();
        });
    }
    readGitignore() {
        return __awaiter(this, void 0, void 0, function* () {
            const filename = path_1.join(this.path, '.gitignore');
            if (utils_1.existsSync(filename)) {
                const content = yield utils_1.readFile(filename);
                this.gitignore = String(content)
                    .split('\n')
                    .filter(line => line.trim() && line.charAt(0) !== '#')
                    .map(pattern => {
                    const mm = new minimatch.Minimatch(pattern, {
                        dot: true,
                    });
                    return (file) => file.includes(pattern) || mm.match(file);
                });
            }
        });
    }
    startWatcher() {
        this.log('Start watcher');
        watch(this.path, {
            recursive: true,
            filter: (filename) => !/\/(node_modules|\.git)\//.test(filename),
        }, debounce((eventName, filename) => {
            const relativeFilename = path_1.relative(this.path, filename);
            const ignored = this.gitignore.some(match => match(relativeFilename));
            if (!ignored) {
                this.log(`${eventName} -> ${filename}`);
                this.expire(true);
            }
        }, 500));
    }
    rsyncGhost(excludeNodeModules) {
        return __awaiter(this, void 0, void 0, function* () {
            this.time(`rsyncGhost(${excludeNodeModules})`);
            if (excludeNodeModules) {
                yield utils_1.exec(`rsync -a ${this.path} ${this.rsyncGhostPath} --exclude '.git/' --exclude 'node_modules/'`);
            }
            else {
                yield utils_1.exec(`rsync -a ${this.path} ${this.rsyncGhostPath} --exclude '.git/'`);
            }
            yield utils_1.writeFile(path_1.join(this.ghostPath, 'package.json'), JSON.stringify(Object.assign({}, this.json, {
                scripts: Object.assign({}, this.json.scripts, { test: 'echo "SKIPPED"' }),
            }), null, 2));
            this.timeEnd(`rsyncGhost(${excludeNodeModules})`);
        });
    }
    cleanGhostAfterPublish() {
        return __awaiter(this, void 0, void 0, function* () {
            const { files: ignoreFilePatterns } = this.json;
            if (ignoreFilePatterns && ignoreFilePatterns.length) {
                this.time('cleanGhostAfterPublish');
                this.time('cleanGhostAfterPublish.glob');
                const toRemoveFiles = [
                    ...yield utils_1.glob('*', {
                        cwd: this.ghostPath,
                        ignore: ['node_modules', ...ignoreFilePatterns],
                    }),
                    ...yield utils_1.glob('!(node_modules)/**/*', {
                        cwd: this.ghostPath,
                        ignore: [...ignoreFilePatterns],
                    }),
                ];
                this.verbose(`(ignore) ${ignoreFilePatterns.join(', ')}`);
                this.timeEnd('cleanGhostAfterPublish.glob');
                this.time('cleanGhostAfterPublish.unlink');
                toRemoveFiles.reverse().forEach(filename => {
                    if (/(^\.|\.json$)/.test(filename)) {
                        return;
                    }
                    const fullFilename = path_1.join(this.ghostPath, filename);
                    try {
                        utils_1.unlinkSync(fullFilename);
                        // this.verbose(`(remove) ${filename}`);
                    }
                    catch (err) {
                        try {
                            if (!utils_1.readDirSync(fullFilename).length) {
                                utils_1.rmdirSync(fullFilename);
                                // this.verbose(`(remove) ${filename}`);
                            }
                        }
                        catch (err) { }
                    }
                });
                this.timeEnd('cleanGhostAfterPublish.unlink');
                this.timeEnd('cleanGhostAfterPublish');
            }
        });
    }
    runNextTask() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.processing && this.tasks.length) {
                this.processing = true;
                const task = this.tasks.shift();
                let hasError = false;
                try {
                    yield task();
                }
                catch (err) {
                    hasError = true;
                    this.taskRetries++;
                    this.log('Task running failed:', this.taskRetries, '(pause 500ms)');
                    yield utils_1.pause(500);
                    if (this.taskRetries > 3) {
                        this.tasks.unshift(task);
                    }
                    else {
                        throw err;
                    }
                }
                finally {
                    if (!hasError) {
                        this.taskRetries = 0;
                    }
                    this.processing = false;
                    this.runNextTask();
                }
            }
        });
    }
}
exports.default = ObservablePackage;
