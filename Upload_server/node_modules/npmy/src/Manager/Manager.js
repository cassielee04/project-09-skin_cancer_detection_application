"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const utils_1 = require("../utils/utils");
const Package_1 = require("../Package/Package");
const ObservablePackage_1 = require("../ObservablePackage/ObservablePackage");
const PackageJSON_1 = require("../PackageJSON/PackageJSON");
class Manager {
    constructor() {
        this.items = [];
        this.itemsIndex = {};
        this.observables = {};
        this.packages = {};
        this.observablePackages = {};
    }
    preparePackage(path, notObservable, initialRC) {
        this.verbose(`prepare package: ${path} [observable: ${!notObservable}]`);
        const isObservable = !notObservable && this.observables[path];
        const collection = isObservable ? this.observablePackages : this.packages;
        if (!collection[path]) {
            const Class = isObservable ? ObservablePackage_1.default : Package_1.default;
            const rc = Object.assign({}, initialRC, (this.itemsIndex[path] ? this.itemsIndex[path].rc : {}));
            const pkgJson = PackageJSON_1.getPackageJSON(path);
            if (!pkgJson) {
                this.verbose(`Bad package.json in ${path}`);
            }
            const { allDependencies } = pkgJson;
            const npmy = Object
                .entries(rc)
                .filter(([name]) => allDependencies.hasOwnProperty(name))
                .reduce((list, [name, path]) => {
                list[name] = this.preparePackage(path, false, rc);
                return list;
            }, {});
            collection[path] = new Class(path, npmy);
        }
        return collection[path];
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const { path } of this.items) {
                yield this.preparePackage(path, true, {}).install(true);
                yield utils_1.pause(1000);
            }
            console.log('--------------------------------------');
            console.log('\x1b[32m NPMy is ready, can start development \x1b[0m');
            console.log('--------------------------------------');
        });
    }
    scan(cwd, include) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield utils_1.glob('**/.npmyrc', {
                cwd,
                dot: true,
            });
            let rc = {};
            const list = yield Promise.all(files.map((name) => __awaiter(this, void 0, void 0, function* () {
                if (name.includes('node_modules')) {
                    return null;
                }
                const filename = path_1.resolve(cwd, name);
                const path = path_1.dirname(filename);
                rc = Object.assign({}, rc, (JSON.parse((yield utils_1.readFile(filename)) + '')));
                Object.keys(rc).forEach(name => {
                    rc[name] = path_1.resolve(path, rc[name]);
                    this.observables[rc[name]] = true;
                });
                return this.addItem(path, rc);
            })));
            if (include) {
                const entries = yield utils_1.glob(include, {
                    cwd,
                    absolute: true,
                });
                yield Promise.all(entries
                    .filter(filename => utils_1.existsSync(path_1.join(filename, 'package.json')))
                    .map((filename) => __awaiter(this, void 0, void 0, function* () {
                    let rc = Object.assign({}, this.itemsIndex[cwd].rc);
                    try {
                        rc = Object.assign({}, rc, JSON.parse((yield utils_1.readFile(path_1.join(filename, '.npmyrc'))) + ''));
                    }
                    catch (err) { }
                    Object
                        .entries(rc)
                        .forEach(([name, path]) => {
                        rc[name] = path_1.resolve(filename, path);
                        this.observables[rc[name]] = true;
                    });
                    list.push(this.addItem(filename, rc));
                })));
            }
            return list.filter(item => !!item);
        });
    }
    addItem(path, rc) {
        if (this.itemsIndex[path])
            return null;
        const data = {
            path,
            rc,
        };
        this.itemsIndex[path] = data;
        this.items.push(data);
        return data;
    }
    verbose(msg) {
        if (process.env.VERBOSE) {
            console.log(`\x1b[33m -> ${msg}\x1b[0m`);
        }
    }
}
exports.default = Manager;
