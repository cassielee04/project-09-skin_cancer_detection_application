"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const semver_1 = require("semver");
const utils_1 = require("../utils/utils");
const PackageJSON_1 = require("../PackageJSON/PackageJSON");
const fs_1 = require("fs");
let SPINNER;
class Package {
    constructor(path, npmy) {
        this.path = path;
        this.npmy = npmy;
        this.json = PackageJSON_1.getPackageJSON(path);
        this.verboseTime = !!process.env.VERBOSE_TIME;
        if (!this.name) {
            console.error(`\x1b[31m ${path}`);
            console.error(this.json, ' \x1b[0m');
            throw new Error('Invalid package');
        }
    }
    get name() {
        return this.json.name;
    }
    hasHook(name) {
        return this.json.scripts.hasOwnProperty(name);
    }
    execHook(name) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.hasHook(name)) {
                this.time(`execHook(${name})`);
                try {
                    yield utils_1.exec(`npm run ${name}`, { cwd: this.getPathToPublished() });
                }
                catch (err) {
                    this.verboseError(`hook "${name}" failed:`, err);
                    // console.error(err);
                }
                this.timeEnd(`execHook(${name})`);
            }
        });
    }
    install(createBinScripts) {
        return __awaiter(this, void 0, void 0, function* () {
            this.installer = this.installer || this.runInstall(createBinScripts);
            yield this.installer;
        });
    }
    createBinScripts(json) {
        return __awaiter(this, void 0, void 0, function* () {
            const exists = {};
            const binRoot = path_1.join(this.path, 'node_modules', '.bin');
            const createBin = (name, pkgPath, bin = {}) => {
                if (typeof bin === 'string') {
                    bin = { [name]: bin };
                }
                const binCommands = Object.keys(bin);
                // Exit
                if (!binCommands.length)
                    return;
                this.verbose(`(bin) ${name} ${binCommands.map((name) => `[${name} -> ${bin[name]}]`).join(', ')}`);
                binCommands.forEach((name) => {
                    const binFilename = bin[name];
                    const filename = path_1.join(binRoot, name);
                    try {
                        fs_1.unlinkSync(filename);
                    }
                    catch (err) { }
                    try {
                        fs_1.symlinkSync(path_1.join(pkgPath, binFilename), filename);
                        fs_1.chmodSync(filename, '755');
                    }
                    catch (err) {
                        this.log(`[failed] createBin: ${name} -> ${binFilename}`);
                        console.error(err);
                    }
                });
            };
            const scanNext = (deps = {}) => {
                Object.keys(deps).forEach((name) => {
                    if (exists[name])
                        return;
                    exists[name] = true;
                    const pkgPath = path_1.join(this.path, 'node_modules', name);
                    const pkgJson = PackageJSON_1.getPackageJSON(pkgPath);
                    if (pkgJson !== null) {
                        createBin(pkgJson.name, pkgPath, pkgJson.bin);
                        scanNext(pkgJson.allDependencies);
                    }
                });
            };
            yield utils_1.checkNodeModulesPath(binRoot);
            createBin(path_1.join(this.path, 'node_modules', json.name), json.bin);
            scanNext(json.allDependencies);
        });
    }
    runInstall(createBinScripts) {
        return __awaiter(this, void 0, void 0, function* () {
            const symLinks = [];
            const toInstall = [];
            const existsDeps = {};
            this.verbose(`Run install (${createBinScripts})`);
            this.time('install');
            (function collect(deps = {}, npmy) {
                Object.keys(deps).forEach((name) => {
                    const version = deps[name];
                    const cleanVersion = version.replace(/[^\d\.]/, '');
                    if (existsDeps[name]) {
                        try {
                            if (existsDeps[name] === cleanVersion || !semver_1.gt(cleanVersion, existsDeps[name])) {
                                return;
                            }
                        }
                        catch (err) {
                            this.verboseError(`${name} "${existsDeps[name]}" -> "${cleanVersion}" (${version})`, err);
                        }
                        this.verbose(`(info)  ${name} "${existsDeps[name]}" -> "${cleanVersion}" (${version})`);
                    }
                    existsDeps[name] = cleanVersion;
                    if (npmy[name]) {
                        const pkg = npmy[name];
                        this.verbose(`\x1b[34m(local) ${name} --> ${pkg.path}`);
                        symLinks.push(pkg);
                        collect.call(this, pkg.json.dependencies, pkg.npmy);
                    }
                    else {
                        this.verbose(`\x1b[35m(npm)   ${name}@${version}`);
                        toInstall.push({
                            name,
                            version,
                        });
                    }
                });
            }).call(this, this.json.allDependencies, this.npmy);
            // Create sym-links
            if (symLinks.length) {
                for (const pkg of symLinks) {
                    const path = path_1.join(this.path, 'node_modules', pkg.name);
                    yield utils_1.checkNodeModulesPath(path);
                    yield pkg.install(false);
                    yield utils_1.rmdir(path);
                    yield utils_1.symlink(pkg.getPathToPublished(), path);
                    yield this.createBinScripts(pkg.json);
                }
            }
            // install npm-packages
            if (toInstall.length) {
                SPINNER = utils_1.createSpinner(` %s [${this.name}] Checking dependencies`, true);
                const deps = toInstall
                    .filter(({ name, version }) => {
                    try {
                        const pkg = PackageJSON_1.getPackageJSON(path_1.join(this.path, 'node_modules', name));
                        return !semver_1.satisfies(pkg.version, version);
                    }
                    catch (err) {
                        // this.verboseError(`${name}@${version} (${this.path})`, err);
                        return true;
                    }
                })
                    .map(({ name, version }) => `${name}@"${version}"`);
                SPINNER.stop(true);
                if (deps.length) {
                    this.log(`npm install ${deps.join(' ')}`);
                    SPINNER = utils_1.createSpinner(` [${this.name}] Installing... %s`, true);
                    yield utils_1.exec(`npm i --no-shrinkwrap --no-package-lock ${deps.join(' ')}`, { cwd: this.path });
                    SPINNER.stop(true);
                }
            }
            this.timeEnd('install');
        });
    }
    getPathToPublished() {
        throw new Error(` ${this.name}#getPathToPublished() Must be implemented`);
    }
    log(...args) {
        let resumeSpinner = false;
        if (SPINNER && SPINNER.isSpinning()) {
            resumeSpinner = true;
            SPINNER.stop(true);
        }
        console.log(` [${this.name}]`, ...args);
        resumeSpinner && SPINNER.start();
    }
    verbose(...args) {
        if (process.env.VERBOSE) {
            let resumeSpinner = false;
            if (SPINNER && SPINNER.isSpinning()) {
                resumeSpinner = true;
                SPINNER.stop(true);
            }
            console.log(`\x1b[33m -> [${this.name}]`, ...args, '\x1b[0m');
            resumeSpinner && SPINNER.start();
        }
    }
    verboseError(...args) {
        process.env.VERBOSE = true;
        this.verbose(`\x1b[31m(error)`, ...args);
        process.exit(1);
    }
    time(label) {
        this.verboseTime && console.time(` [${this.name}] ${label}`);
    }
    timeEnd(label) {
        this.verboseTime && console.timeEnd(` [${this.name}] ${label}`);
    }
}
exports.default = Package;
