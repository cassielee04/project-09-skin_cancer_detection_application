"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const minimist = require("minimist");
const Manager_1 = require("./src/Manager/Manager");
const utils_1 = require("./src/utils/utils");
const PackageJSON_1 = require("./src/PackageJSON/PackageJSON");
const { _: targetPaths = [], include, add, verbose, version } = minimist(process.argv.slice(2));
process.on('unhandledRejection', (reason, p) => {
    console.log('\x1b[31m----------------------------');
    console.error('Unhandled Rejection at promise:', p);
    console.error('Reason:', reason);
    console.log('----------------------------\x1b[0m');
    process.exit(1);
});
if (version) {
    console.log(`NPMy v${require('./package.json').version}`);
    process.exit(0);
}
console.log(`\x1b[32mNPMy\x1b[0m (ctrl+c -> exit)`);
console.log(` - tmp: ${utils_1.tmpdir()}`);
try {
    // rmdirSync(tmpdir());
    utils_1.mkdirSync(utils_1.tmpdir());
}
catch (_) { }
add && console.log(` - add: ${add}`);
include && console.log(` - include: ${include}`);
if (verbose) {
    console.log(` - verbose: enabled`);
    process.env.VERBOSE = true;
}
console.log(`---------------------`);
// Autorun
(function () {
    return __awaiter(this, void 0, void 0, function* () {
        const manager = new Manager_1.default();
        !targetPaths.length && targetPaths.push('.');
        if (add) {
            const list = yield utils_1.glob(add);
            const records = {};
            list.forEach(realtivePath => {
                const path = path_1.resolve(realtivePath);
                const json = PackageJSON_1.getPackageJSON(path);
                if (json) {
                    records[json.name] = path;
                }
            });
            console.log(` - Added ${Object.keys(records).length} packages`);
            console.log(JSON.stringify(records, null, 2));
            targetPaths.forEach(targetPath => {
                const filename = path_1.resolve(path_1.join(targetPath, '.npmyrc'));
                const json = utils_1.existsSync(filename) ? JSON.parse(utils_1.readFileSync(filename) + '') : {};
                utils_1.writeFileSync(filename, JSON.stringify(Object.assign({}, json, records), null, 2));
            });
        }
        for (const relativePath of targetPaths) {
            const path = path_1.resolve(relativePath);
            const spinner = utils_1.createSpinner(` %s ${path}`, true);
            const lists = yield manager.scan(path, include);
            spinner.stop(true);
            console.log(` ${path}`);
            lists.forEach(({ path: pkgPath, rc }) => {
                const { allDependencies } = PackageJSON_1.getPackageJSON(pkgPath);
                console.log(`   /${path_1.relative(path, pkgPath)}`);
                Object.keys(rc)
                    .filter((depName) => allDependencies.hasOwnProperty(depName))
                    .forEach((depName) => {
                    console.log(`     [${depName}] -> ${rc[depName]}`);
                });
            });
        }
        console.log('\nRunning');
        yield manager.run();
    });
})();
